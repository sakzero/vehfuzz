# vehfuzz 协议解析层实现说明（面向非车载协议专家）

本文档解释当前仓库中 **vehfuzz 的“协议解析层”**到底做了什么、怎么组织、关键算法是什么、为什么需要做成现在这种形态，以及在不同“现实接入条件”（能/不能抓到某些层的数据、加密能/不能解、是否拿得到 DBC 等）下会出现哪些情况。

适用范围：
- 你能理解“字节/报文/字段/校验/长度”这些基础概念，但 **不熟悉车载协议族（CAN/UDS/DoIP/SOME/IP/J1939 等）**；
- 当前项目暂时 **无 UI**，协议层主要为后续 fuzz 层/日志分析服务；
- 车端系统多为封闭固件，很多“能不能拿到某层数据/密钥”取决于车型与接入方式，本文会把这些不确定性讲清楚。

> 读完你至少能回答：  
> 1) vehfuzz 的协议层是“分层/插件化”的，入口/输出在哪；  
> 2) 每个任务书协议目前能解析到哪一层、输出哪些字段；  
> 3) Wi‑Fi 加密/蓝牙 HCI/DBC 可用性为什么会导致能力差异；  
> 4) 遇到“协议变种/自定义协议”时，什么时候可以不改代码，什么时候必须加插件。

---

## 1. 协议解析层在 vehfuzz 里处于什么位置？

把 vehfuzz 看成一条流水线（无 UI 的“跑批”工具）会更好理解：

1. **读取配置**（YAML/JSON）  
2. **读取种子样本**（seed：一批正常报文/pcap/日志导出）  
3. **变异**（mutate：把 seed 的字节改掉）  
4. **协议层 build_tx**：把“变异后的字节”封装成“真正要发的报文”（必要时修长度/校验/头字段）  
5. **发包/收包（在线）或落盘（离线）**  
6. **协议层 parse（解析）**：把 TX/RX 的原始字节翻译成结构化字段（fields）  
7. **事件落盘**：写入 `artifacts/events.jsonl` 供后续统计/复现/回归

协议解析层主要对应第 4 步（build_tx）与第 6 步（parse），并且提供统一的解析输出结构。

---

## 2. 协议层的“输入”和“输出”是什么？

### 2.1 输入：Message（字节 + 元数据 meta）

协议层处理的基本单位是 `Message`：
- `data: bytes`：报文原始字节
- `meta: dict`：一些“上层不在字节里但必须知道的信息”（例如 CAN ID、是否 CAN FD、PCAP linktype 等）

定义在：`fuzz/vehfuzz/src/vehfuzz/core/plugins.py`

为什么需要 meta？  
因为现实里很多总线协议的“外层信息”并不一定在 `data` 里：
- CAN：ID/扩展帧/是否 FD/是否 BRS 等通常来自硬件接口或日志，不在 0~64 字节 data 里；
- PCAP：链路层类型（Ethernet 还是 802.11 还是 HCI H4）来自 PCAP 全局头，不在每个包里；
- DoIP/UDS：为了生成更稳定的会话键（flow_key），可能需要源/目的地址等上下文。

### 2.2 输出：ParsedMessage（统一的“结构化解析结果”）

所有协议的 `parse()` 都尽量输出统一结构 `ParsedMessage`（可 JSON 序列化）：

- `protocol`：协议名（如 `can` / `uds` / `doip` / `someip` / `wifi` …）
- `level`：解析到哪一层（`raw/l2/l3/l4/app`，越靠后越“语义化”）
- `ok`：解析器是否成功产出“有意义的结构”（不等于“绝对正确”，而是“可用于 fuzz/统计”）
- `encrypted`：报文存在但负载不可见（典型：802.11 Protected Frame 未解密）
- `reason`：如果不完整/失败，给出原因（例如 too_short、protected_data_frame）
- `flow_key`：会话/流标识，用于把相关报文聚类（例如同一 TCP 五元组、同一 DoIP 源/目的地址）
- `fields`：解析出的字段字典（核心产物）
- `payload`：一个 `(offset,length)`，指示“建议 fuzz 的 payload 在原始字节中位于哪里”

定义在：`fuzz/vehfuzz/src/vehfuzz/core/parsed.py`

为什么要有 `payload(offset,length)` 而不是直接拷贝 payload 字节？  
因为事件日志里已经有原始 `hex`，`payload` 用“指针”（偏移/长度）引用原始字节，避免重复存储，也更方便对齐“你 fuzz 的到底是哪一段”。

---

## 3. 协议层是怎么“接入引擎”的？（不需要 UI 也能看懂输出）

### 3.1 运行时选择协议插件：campaign.protocol

引擎会从配置里读取：
- `campaign.protocol`：协议名（默认 `raw`）
- `campaign.protocol_config`：该协议的配置字典

位置：`fuzz/vehfuzz/src/vehfuzz/core/engine.py`（读取 `protocol_config` 并 `create_protocol()`）

### 3.2 插件注册机制（为什么说它是“插件化”的）

协议插件通过装饰器注册到全局表里：
- `@register_protocol("someip")`
- `@register_protocol("can")`
- …

注册/创建在：`fuzz/vehfuzz/src/vehfuzz/core/plugins.py`

你可以运行查看当前内置插件列表（会输出 protocols/adapters/oracles）：
```bash
python fuzz/vehfuzz/scripts/vehfuzz.py plugins
```

### 3.3 安全解析：解析出错不会把 fuzz 跑崩

引擎调用解析时不是直接 `protocol.parse()`，而是包了一层 `_safe_parse()`：
- 解析异常会被捕获；
- 解析失败会写到事件字段 `parse_error`/`tx_parse_error`；
- 引擎继续跑下一条用例。

位置：`fuzz/vehfuzz/src/vehfuzz/core/engine.py`

### 3.4 最重要的产物：events.jsonl（你后续做统计/复现都靠它）

每次用例至少会记录一个 `mutation` 事件（以及在线模式下的 `tx/rx`）：
- `tx_hex`/`hex`：原始报文
- `tx_parsed`/`parsed`：结构化解析结果
- `tx_payload_hex`/`payload_hex`：根据 `payload(offset,length)` 切片得到的 payload 十六进制（便于你快速看 fuzz 的“核心内容”）

运行结果目录在 `runs/<run_id>/`，重点文件：
- `artifacts/events.jsonl`
- `artifacts/summary.json`
- `report.md`

路径创建：`fuzz/vehfuzz/src/vehfuzz/core/artifacts.py`

### 3.5 seeds 是怎么来的？（不同 seed 形态决定协议层能解析到哪）

vehfuzz 的协议层并不是“凭空解析”，它依赖 seed 的来源把必要的 meta 带进来。常见 seed 形态有：

1) **CAN seeds（字节 + can_id）**  
- 典型来源：CANalyzat0r 导出、candump 日志解析等  
- 关键 meta：`can_id / is_extended / is_fd / timestamp / source`  
- 代码里 CANalyzat0r 导入会把 `can_id` 解析出来并放进 meta（见 `fuzz/vehfuzz/src/vehfuzz/core/corpus.py`）

2) **PCAP/PCAPNG seeds（每包字节 + pcap_global）**  
- 典型来源：网络抓包（Ethernet、802.11、Bluetooth HCI H4 等）  
- 关键 meta：`pcap_global.linktype`（决定你这是 Ethernet、802.11 还是 HCI H4）  
- 代码会在读取 pcap 时写入：
  - `meta.pcap_global.linktype`（全局链路层类型）
  - `meta.pcap.*`（每包时间戳、原始长度等）
  - 见 `fuzz/vehfuzz/src/vehfuzz/core/corpus.py`

为什么这点重要？  
因为 Wi‑Fi/Bluetooth 的解析器会先看 `pcap_global.linktype` 决定走哪条解析路径；如果你没有用 pcap seed（或 meta 缺失），解析器只能退化成 raw（只知道“这是一串 bytes”）。

---

## 4. 协议层不仅是“解析”，还负责“封装/修正”（build_tx）

如果只做“字节随机改”，很多协议包会因为长度/校验不一致而直接被丢弃，导致 fuzz 无效。
因此协议层的 `build_tx()` 经常会做这些事情：
- **重算长度字段**：例如 SOME/IP 的 length、DoIP 的 payload_len、L2CAP 的 len；
- **保持包结构完整**：例如 Wi‑Fi 离线 PCAP 里重算 IPv4/TCP/UDP checksum；
- **从更高层生成合法报文**：例如 NMEA 生成合法 `$...*CS`；
- **把变异字节映射到“信号值”而不是 raw bytes**：DBC 信号级 fuzz。

这也是“协议层为 fuzz 层服务”的核心原因：**让变异后的数据“更像真的协议包”，能更深地触发车端解析逻辑。**

### 4.1 引擎的“变异字节 mutated”是怎么进入协议层的？

引擎每条用例都会先生成 `mutated: bytes`，然后交给协议层 `build_tx(seed, mutated)`。协议层常见有两种用法：

1) **mutated 直接就是 payload**（协议层负责封装头/长度/校验）  
例如：SOME/IP、DoIP、NMEA、Bluetooth(ACL/L2CAP)、Wi‑Fi(IPv4/TCP/UDP)

2) **mutated 不是 payload，而是“变异熵/变异指令源”**  
例如：CAN DBC 信号级 fuzz  
协议层不会直接把 mutated 当 CAN data，而是用 mutated 生成“稳定可复现”的信号变异，再由 DBC 编码成 CAN data。

---

## 5. 任务书协议逐项说明：当前实现到什么程度？

> 本节按“输入形态 → 解析层级 → 输出字段 → payload 选择 → 关键算法/局限”来讲。

### 5.1 raw（兜底协议）

用途：当你还没确定协议/接入方式，或者想做纯字节黑盒 fuzz 时使用。  
特点：build_tx 基本不做封装；parse 只给最基础信息（如长度）。

协议插件位置：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/raw.py`

---

### 5.2 CAN / CAN FD（含 ISO‑TP + UDS best-effort）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/can.py`

#### 输入形态
- `Message.data`：CAN 帧 data（经典 CAN 通常 ≤8 字节；CAN FD 可到 64 字节）
- `Message.meta`：至少需要 `can_id`，并可携带 `is_fd/is_extended/bitrate_switch` 等

为什么 CAN 必须有 meta.can_id？  
因为 CAN ID 不是 data 的一部分，但它决定了：
- ECU/功能的分组（同一个 ID 往往对应同一类报文）
- 上层协议映射（诊断常见 ID：0x7DF/0x7E0/0x7E8 等）

#### parse() 输出（帧级）
`fields` 里包含：
- `can_id / is_extended / is_fd / dlc / len`
- `isotp`：如果识别出 ISO‑TP，会给出帧类型/总长度/序号等（best-effort）
- `inner_uds`：如果能重组出 UDS payload，会进一步解析 UDS（best-effort）
- `inner_uds_hex`：对应 UDS payload 的 hex（便于直接观察）

#### payload 选择
当前 CAN 的 `payload` 指向整个 `data`（offset=0, length=len(data)），因为 CAN data 很短，通常就从整段开始 fuzz。

#### 常用 protocol_config（你可以理解成“协议层的开关”）
- `can_id`：默认 CAN ID（如果 seed.meta 里没有 can_id）
- `is_fd`：默认是否 FD
- `is_extended`：默认是否扩展帧（默认会根据 can_id 是否 > 0x7FF 推断）
- `bitrate_switch`：CAN FD BRS 位
- `max_len`：对 `mutated` 取前多少字节作为 CAN data（默认 FD=64，否则 8）
- `pad_to_len` / `pad_byte`：把 data 补齐到固定长度（某些 ECU/网关更偏好固定长度）
- `parse_isotp`：是否尝试 ISO‑TP 识别/重组（默认 true）

#### 关键算法：ISO‑TP 识别与重组（为什么能“看到 UDS”）
CAN 本身一帧最多 8/64 字节；诊断 UDS 往往更长，因此常用 ISO‑TP 分片。
本项目实现了 ISO‑TP 的解析与重组核心（见下一节），CAN 插件在识别到 ISO‑TP 后：
- 单帧（SF）直接把 payload 当 UDS 解析；
- 首帧/连续帧（FF/CF）会把分片喂给重组器，凑齐后再解析 UDS。

局限：  
重组需要你抓到完整分片序列；乱序/丢帧/多会话混杂都会降低“内嵌 UDS”成功率，但不会影响 CAN 帧级解析。

---

### 5.3 ISO‑TP 核心算法（CAN FD 也支持）

实现位置：`fuzz/vehfuzz/src/vehfuzz/core/isotp.py`

ISO‑TP 把一条长消息拆成多帧：
- SF（Single Frame）：单帧承载全部 payload
- FF（First Frame）：多帧消息的第一帧，携带总长度
- CF（Consecutive Frame）：后续连续帧，携带序号（0~15 循环）
- FC（Flow Control）：流控帧（发送端/接收端状态机使用）

#### 5.3.1 parse_isotp_frame：识别每帧类型并提取字段
根据第 1 个字节（PCI）的高 4 位判断类型：
- `0x0`：SF  
  - 经典格式：低 4 位是长度（0..7）  
  - CAN FD 扩展：如果低 4 位为 0，则长度在第 2 字节（1..255）
- `0x1`：FF  
  - 12-bit 长度（前两字节拼出来）非 0：直接作为总长度  
  - 如果 12-bit 长度为 0：使用 32-bit 扩展长度（后续 4 字节）
- `0x2`：CF（低 4 位是 seq）
- `0x3`：FC（低 4 位是 FS，后跟 BS/STmin）

#### 5.3.2 reassemble_feed：把 FF/CF 拼回完整 payload
维护一个 `IsoTpReassembly` 状态：
- `total_len`：目标长度
- `buf`：已收集 payload
- `next_seq`：下一个期望的 CF seq

逻辑（简化理解）：
- SF：直接返回 payload（并 reset 状态）
- FF：reset → 记录 total_len → 把 FF 自带 payload 放入 buf → 等待 CF
- CF：如果 seq 不匹配，reset 丢弃；匹配则追加 payload；buf 达到 total_len 就输出完整 payload 并 reset
- FC：此处只解析字段，不做流控状态机（因为实际收发流控通常由底层适配器/目标栈决定）

为什么要支持 CAN FD？  
CAN FD 下每帧可变长（8/12/16/…/64），SF/FF/CF 的“可用 payload”长度不同，解析与构造必须按实际帧长处理。

---

### 5.4 UDS（统一诊断服务，常跑在 ISO‑TP 或 DoIP 之上）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/uds.py`

UDS 你可以先把它理解成“诊断 API”：
- 请求：`SID + 参数…`
- 响应：正响应（`SID+0x40`）或负响应（`0x7F + 原SID + NRC`）

#### parse() 输出
解析至少会提取：
- `sid`
- 是否负响应（0x7F）以及 `nrc`（Negative Response Code）的含义（常见 NRC 会映射成名字）

#### flow_key 生成（为什么要做这个）
同样是 UDS，如果你只按 `sid` 聚类会很粗。
实现会优先利用 meta 中的上下文：
- 如果 msg.meta 里有 DoIP 源/目的地址：`uds:doip:src->dst`
- 其次如果 meta 里有 isotp 的 tx/rx id：`uds:isotp:tx->rx`
- 否则退化为 `uds:sid=0x..`

这会让你后续在 `events.jsonl` 里更容易把同一诊断会话的请求/响应对上。

#### 常用 protocol_config（UDS 插件侧）
UDS 插件本身更偏“解析”。通常你会在 ISO‑TP 或 DoIP 层完成“传输层封装”，UDS 这里只负责把 payload 翻译成可读字段与 flow_key，因此目前没有特别复杂的 build_tx 参数。

---

### 5.5 J1939（含 TP.CM/TP.DT 重组）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/j1939.py`

J1939 是基于 CAN 扩展帧（29-bit ID）的上层规范，常见于商用车/工程车辆等。
它的 ID 字段本身就携带了大量语义。

#### 5.5.1 ID 解析（PGN/SA/DA）
通过 29-bit CAN ID 拆出：
- priority
- data page
- PDU format / PDU specific
- source address（SA）
- destination address（DA，取决于 PF 是否 < 240）
- PGN（Parameter Group Number）

这一步是“把一串 can_id 变成可读字段”的关键。

#### 5.5.2 TP（Transport Protocol）重组
J1939 也有“大报文分包”的机制：
- TP.CM（PGN 0x00EC00）：控制消息（BAM/RTS 等），包含总长度、总包数、目标 PGN
- TP.DT（PGN 0x00EB00）：数据分包（序号 + 7 字节数据）

当前实现（best-effort）：
- 看到 TP.CM 的 BAM(0x20)/RTS(0x10) 时创建重组状态（按 SA/DA/target_pgn 建索引）
- 看到 TP.DT 时按 seq 递增拼接
- 拼到 `total_len` 或到最后一个包时，输出 `tp_payload_hex` 并标记 `reassembly_complete`

局限：  
TP 的完整状态机（CTS/ACK/并发会话等）很复杂；当前实现优先满足“能把常见分包拼起来给 fuzz/分析用”。

---

### 5.6 CAN DBC（信号级解析/生成）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/can_dbc.py`

**这是你目前最确定“应该能拿到”的能力（DBC）**，因此这里讲详细一点。

DBC 是“CAN 报文定义文件”，里面写了：
- 某个 frame_id（CAN ID）对应哪些 signals（信号）
- 每个 signal 的起始位/长度/缩放/偏移/取值范围/枚举等

你可以把它理解成：  
**没有 DBC：你只能对 8/64 字节乱改**  
**有 DBC：你可以对“车里真的有意义的信号值”做变异**

#### 依赖与配置（重要：缺依赖直接报错，不降级）
- 需要 `cantools`：没装会抛错提示安装  
  - 可用：`python -m pip install -r fuzz/vehfuzz/requirements-dbc.txt`
- 配置必须提供 `protocol_config.dbc_path`（相对路径会按 config_dir 解析）

#### build_tx 的核心思路：把 mutated bytes 当“可重复的随机源”
关键设计点：
- 引擎上游的变异输出是 `mutated: bytes`（字节序列）
- DBC 信号级 fuzz 不是“直接把 mutated 当 CAN data”，而是：
  1) 用 `mutated` + 一点盐（dbc 路径、frame_id 等）算一个稳定的随机种子（hash）  
  2) 用这个随机源决定“挑哪些 signal 改”“改成什么值”  
  3) 用 cantools 按 DBC 规则把 signals 编码回 CAN data

这样做的好处：
- **可复现**：同一个 `mutated` 会生成同样的信号变异（方便回放/复测）
- **更语义化**：多数 ECU 会对信号值做逻辑处理，比随机字节更容易触发深层路径

#### parse() 的作用
收到/发出的 CAN data 会尝试按 DBC 解码成 `signals` 字典（如果 frame_id 能匹配到 DBC message）。

局限：
- 你的 DBC 必须与真实车的报文定义一致；如果车型/版本不一致，会出现“解码失败/信号不合理”的情况。

#### 常用 protocol_config（建议你们项目里优先固化成模板）
- `dbc_path`（必填）：DBC 文件路径（相对路径按 config_dir 解析）
- `frame_id`：指定要 fuzz 的帧 ID（不填则取 seed.meta.can_id）
- `message_name`：按 DBC message 名称选择（比 frame_id 更直观；有时同 ID 多定义需注意）
- `min_signals` / `max_signals`：每次用例随机挑多少个信号做变异（默认 1..min(4,总信号数)）

为什么既支持 frame_id 又支持 message_name？  
现实里车型版本可能导致同一个 ID 对应不同命名/不同信号集合；提供两种选择方式更稳妥。

#### 一个很关键但容易忽略的实现细节：__config_dir
引擎会把 `protocol_config["__config_dir"]` 注入进去（值为 run 的 config_dir），用于把 `dbc_path` 这种相对路径解析成绝对路径。  
这让你在项目里写配置时可以用相对路径，不必硬编码绝对路径。

---

### 5.7 SOME/IP（车载以太网常见应用层）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/someip.py`

#### parse() 输出
会解析 SOME/IP 固定头（16 字节）：
- `service_id / method_id / client_id / session_id`
- `protocol_version / interface_version`
- `message_type`（request/response/error 等）及其名称
- `return_code` 及其名称
- `length_matches`：长度字段与实际 payload 是否一致（用于快速判断报文是否“格式自洽”）

#### build_tx 的关键点：自动重算 length
SOME/IP 的 length 字段是“payload + 8”的长度（规范要求）。
因此 build_tx 会根据 `mutated` 自动填充 length，避免你 fuzz 一改 payload 就让包结构自毁。

#### 关键算法：请求-响应关联（correlation）
为了让后续 fuzz/分析更容易判断“同一次请求导致了什么响应”，实现维护一个小缓存：
- 以 `(client_id, session_id)` 为键记录最近一次 request 的信息
- 当看到 response/error 时，写入 `fields["correlates_to"]` 指向对应 request

局限：  
这是 best-effort 关联，不是完整会话协议栈（例如 UDP 丢包、重复包会影响关联）。

#### 常用 protocol_config
- `service_id / method_id`
- `client_id / session_id`
- `protocol_version / interface_version`
- `message_type`（request/notification/response 等，按 SOME/IP 枚举）
- `return_code`（通常请求侧为 0）

---

### 5.8 SOME/IP-SD（Service Discovery，服务发现）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/someip_sd.py`

SD 报文结构大致是：
- SOME/IP 头（16 字节）
- SD payload：
  - flags + reserved
  - entries_len + entries
  - options_len + options

#### parse() 输出（核心）
会把：
- `entries`（每个 entry 16 字节）解析成列表，包含 type/service_id/instance_id/ttl/版本等
- `options`（每个 option 是 `2字节len + type + reserved + data`）解析成列表，并对常见 option（IPv4/IPv6 endpoint）进一步解析 IP/port/proto
- 最后做 best-effort 的“entry → options”解析关联（按 entry 里带的 options index/num 指向 options 列表切片）

为什么 SD 解析很重要？  
因为没有 SD，你只知道“总线上有 UDP 包”，但不知道“它在发布什么服务/端口”；解析 SD 能让你在 fuzz 前期快速建立服务地图（服务 ID、实例、端口等）。

#### 常用 protocol_config
- `max_entries_len`：对变异输入截断成 entries 字节流的最大长度（防止生成超大 SD 包）
- `reboot / unicast / flags`：SD flags（可用 flags 直接指定）
- `service_id/method_id/...`：SOME/IP 头相关字段（多数情况下保持默认即可）

---

### 5.9 DoIP（诊断 over IP，常与 UDS 组合）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/doip.py`

DoIP 报文头固定 8 字节：
- version / inverse_version（互为按位取反，用于简单一致性校验）
- payload_type
- payload_len

#### parse() 输出
会解析头字段并检查：
- `inverse_ok`
- `payload_len_matches`（声明长度是否不超过实际可用长度）

并对常见 payload_type 做更深入解析：
- routing activation request/response
- alive check response
- diagnostic message（0x8001）：解析 `diag_src/diag_dst`，并对后续 UDS payload 继续内嵌解析

#### build_tx 的关键点：自动填 payload_len
`payload_len` 直接取 `len(mutated)`，保证格式自洽。

#### 常用 protocol_config
- `version` / `inverse_version`：默认 DoIP 版本与反码（一般不用改）
- `payload_type`：你要构造哪种 DoIP payload（默认 0x8001 诊断消息）

---

### 5.10 Bluetooth（HCI/H4 → ACL → L2CAP → SDP/RFCOMM best-effort）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/bluetooth.py`

这里必须先解释“为什么蓝牙会有两种情况”：  
蓝牙的协议分层很深，但你能抓到哪一层，取决于你控制的是：
- **空口（无线电）**：通常抓到的是 802.11 类似的射频/基带层，解析难、还可能加密；
- **控制器 HCI**：这是 host 与 controller 的边界，能看到 HCI Command/Event/ACL，是最适合做协议级 fuzz 的位置；
- **操作系统 socket 层**：你只能看到应用数据，不一定能看到 HCI/L2CAP 细节。

当前实现主要面向“能拿到 HCI 的离线 PCAP”：
- PCAP linktype=187/201（HCI H4 / HCI H4 with PHDR）
- 解析 H4 packet type：
  - 0x01：HCI Command（解析 opcode/ogf/ocf）
  - 0x04：HCI Event（解析 event_code，并对 Command Complete/Status 取关键字段）
  - 0x02：ACL（继续解析 L2CAP，进一步 best-effort 解析 SDP/RFCOMM）

#### build_tx（为什么它不只是 parse）
对 ACL 数据（ptype=0x02），build_tx 会尝试：
- 只变异 L2CAP/SDP/RFCOMM 的 payload 部分
- 同步修正 `L2CAP length`、`ACL length` 等字段
从而保证变异后的包仍然“结构自洽”，利于后续复现与更深层触发。

局限：
- 如果你现实里拿不到 HCI（只能拿应用层），这套 HCI/ACL/L2CAP 解析就用不上；那属于“数据源限制”，需要另一条测试路径（例如对应用层协议 fuzz）。

#### 常用 protocol_config（离线 PCAP 变异行为开关）
- `layer`：`auto/l2cap/sdp/rfcomm`（默认 auto，优先识别并只变异该层 payload）
- `preserve_packet_len`：是否保持整包长度不变（默认 true，便于回放）
- `preserve_l2cap_len` / `l2cap_max_len`：L2CAP payload 长度策略
- `preserve_sdp_param_len` / `sdp_param_max_len`：SDP 参数变异长度策略
- `preserve_rfcomm_info_len` / `rfcomm_info_max_len`：RFCOMM info 变异长度策略
- `rfcomm_fix_fcs`：是否重算 RFCOMM FCS（默认 false；部分场景你可能希望保留原 FCS 做“畸形帧”测试）

---

### 5.11 Wi‑Fi（802.11 / Radiotap / Ethernet 输入；可选 CCMP 解密后解析 TCP/IP）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/wifi.py`

Wi‑Fi 这块最容易让人困惑，因为“你说的 Wi‑Fi 数据”在不同采集点形态完全不同：

#### 情况 A：你拿到的是“入网后的明文 TCP/IP”
例如：
- 设备连上车载 Wi‑Fi 后，你在系统里主动发 TCP/UDP 请求去测车机服务；
- 或者你抓到的是 Ethernet/IPv4 的 PCAP（linktype=1），本质上已经是明文网络包。

这时 **不需要解密**，因为你 fuzz 的对象是“你发出去的明文请求”，加密发生在更底层（网卡/驱动）。
当前实现能解析到：
- Ethernet → IPv4 → TCP/UDP，并生成五元组 `flow_key`（src/dst ip+port）。

#### 情况 B：你拿到的是“空口 802.11 帧（可能加密）”
例如你用网卡监听模式抓到 Radiotap/802.11 的 PCAP（linktype=127/105）。

这时存在两种子情况：
- B1：数据帧未加密（Protected bit=0）→ 可继续 LLC → IPv4 → TCP/UDP
- B2：数据帧加密（Protected bit=1）→ payload 不可见

对于 B2，本实现的行为是：
- 如果没有配置解密：`ParsedMessage.encrypted=true`，reason=`protected_data_frame`，并在 `fields.decrypt` 里标注“是否配置了解密能力”
- 如果配置了解密（见下文）：尝试 CCMP 解密，成功则继续解析 TCP/UDP

#### 5.11.1 为什么“必须能解密才谈得上 TCP/IP fuzz”？
因为 TCP/IP 头和 payload 都在 802.11 data 帧的加密部分里；看不到明文就无法：
- 正确识别端口/协议/会话；
- 定位 payload；
- 做字段级变异（只能做“密文比特翻转”，通常效果很差）。

#### 5.11.2 CCMP 解密的实现方式与限制（必须说明清楚）
当前 Wi‑Fi 解密实现的是：**在你提供 CCMP 的 TK（Temporal Key）时，尝试对单个 802.11 data 帧做 CCMP 解密与 MIC 校验**。

配置项：
- `campaign.protocol_config.decrypt.ccmp_tk_hex`：16 字节 TK 的十六进制（32 个 hex 字符）

重要：只要你配置了 `decrypt`，就会强制校验：
- key 必须是合法 hex 且长度=16 字节
- 必须安装 `pycryptodomex`，否则直接报错提示安装（不静默降级）

解密算法关键点（高层理解）：
- CCMP 使用 AES-CCM（带认证的加密）
- 从 802.11 头 + CCMP header 提取 PN（Packet Number）
- 构造 nonce（优先取 QoS TID、Addr2、PN）
- 构造 AAD（对 802.11 头做一定的掩码处理后作为附加认证数据）
- 用 AES-CCM `decrypt_and_verify` 解密并校验 MIC

限制（非常重要，避免误解“Wi‑Fi 全都能解密”）：
- 本实现 **不负责从 WPA2 四次握手推导 PTK/TK**（那需要抓握手、还要知道 PSK/PMK 等）；  
 也就是说：你必须以某种方式“已知 TK”，才能让这里解密成功。
- 只实现 CCMP 这一路径；若车型使用 GCMP/其他加密套件，需要扩展实现。

#### 5.11.3 Wi‑Fi build_tx：为什么能“离线 PCAP 变异后仍然合法”
Wi‑Fi 协议插件不是简单把 mutated 当整包替换，而是支持“变异 L4 payload 并重算校验”：
- 对 IPv4 会重算 header checksum
- 对 UDP/TCP 会重算伪首部校验和
- 支持“保持原始 payload 长度”或允许扩展（由配置控制）

这使得你生成的 `mutated.pcap` 更可能被协议栈接受，从而更适合做离线回放/复现。

#### 常用 protocol_config（离线 PCAP 变异策略）
- `preserve_packet_len`：是否保持整包长度（默认 true）
- `preserve_payload_len`：是否保持 L4 payload 长度（默认 true；更像“轻度变异”）
- `payload_max_len`：允许扩展 payload 时的上限
- `decrypt.ccmp_tk_hex`：配置后启用 CCMP 解密（必须 16 字节 hex；缺库直接报错）

为什么要默认 preserve_len？  
因为离线回放/复现时，很多工具/设备对“长度突然变化”的包更敏感；先保持长度不变，更容易把问题定位在“字段内容”而不是“结构完全变了”。

---

### 5.12 GNSS（NMEA 0183 解析 + 场景句子生成）

协议插件：`fuzz/vehfuzz/src/vehfuzz/plugins/protocols/nmea.py`（注册名：`gnss` / `nmea`）

#### parse() 输出
- 解析 `$BODY*CS` 结构
- 计算 checksum 并输出 `checksum_matches`
- 提取 `talker` 与 `sentence`（例如 `GP` + `RMC`），并生成 `flow_key=nmea:GP:RMC`

#### build_tx：场景模拟为什么属于协议层
任务书要求“模拟各种定位场景”。现实里 GNSS 模拟器可能是硬件设备（射频注入），但在当前“协议层”里我们做的是软件层面：
- 按配置的 scenario 生成合法的 RMC 句子（位置/速度/航向）
- 支持 static/circle、抖动、概率性丢定位（status=V）
- 统一重算 NMEA checksum

你可以把它理解为：先把“协议格式/校验”问题解决，让后续 fuzz/注入更稳定；硬件级射频模拟属于后续硬件接口层工作。

#### 常用 protocol_config
- `max_body_len`：非 scenario 模式下，限制 NMEA BODY 最大长度（防止 havoc 生成超长字符串）
- `scenario`（可选 dict）：
  - `type: static|circle`
  - `lat/lon`
  - `step_s`
  - `radius_m`、`angular_speed_deg_per_step`（circle）
  - `jitter_deg`（抖动幅度）
  - `drop_fix_prob`（丢定位概率）

---

## 6. 为什么现实里会有“能解析/不能解析”的情况？（把不确定性讲清楚）

你现在还没对接车企，很多信息未知很正常。协议层之所以按现在的方式设计，就是为了适应这些不确定性：

### 6.1 数据采集点不同 → 看到的层级不同

同一个“Wi‑Fi 通信”，你可能拿到：
- 空口 802.11（大量加密）  
- 入网后 TCP/IP（明文）  
- 应用层 HTTP/自定义协议（更上层）

同一个“蓝牙通信”，你可能拿到：
- HCI（最适合协议级 fuzz）  
- 仅应用层 socket（看不到 HCI/L2CAP）  
- 甚至只拿到日志字符串

因此协议层设计成：
- 能从 meta 判断输入形态（例如 PCAP linktype）
- 先做“能做的解析”，做不到就标注 `encrypted/reason/level`
- 不会因为某个深层解析失败就让整体崩溃

### 6.2 加密是“正常现象”，不是异常

Wi‑Fi：WPA2/WPA3 下空口数据帧通常加密。  
这不代表不能 fuzz，而是要选对接入点：
- 你若能“入网并主动发请求”，仍然能 fuzz 明文 TCP/IP 语义；
- 你若只能抓空口密文，想做语义 fuzz 就需要解密能力（密钥/握手/推导等）。

蓝牙：部分层也可能加密或难以抓取，HCI 是更合适的接口层。

### 6.3 DBC 是否可得决定 CAN fuzz 的“语义深度”

你说第三个“应该能拿到 DBC”——这是很关键的信息。原因：
- 没 DBC：你只能做“字节级 CAN fuzz”，效果取决于 ECU 是否对 raw bytes 有健壮解析
- 有 DBC：你能做“信号级 fuzz”，更贴近车辆真实功能/控制逻辑

DBC 也可能出现“版本/车型不一致”的情况，这会导致解码/含义偏差，但信号级 fuzz 仍然往往比纯字节更有效。

---

## 7. 遇到“自定义协议/协议变种”时，需要改代码吗？

这里给你一个清晰的判断准则：

### 7.1 不改代码也能继续 fuzz 的情况（黑盒 payload）
只要外层是标准协议（CAN/DoIP/SOMEIP/TCP/UDP 等），即使 payload 内部是厂商私有协议：
- 协议层仍然能解析外层头，给你 `flow_key` 与 payload 的定位
- fuzz 层可以对 payload 做字节级/长度级/序列级变异

这属于“黑盒 fuzz”，通常是项目早期最稳妥的路径。

### 7.2 需要改代码/加插件的情况（字段级/状态机级）
当你希望：
- 不是乱改 payload，而是按字段（cmd/len/seq/crc…）变异；
- 或者按状态机生成“协议交互序列”（登录→请求→确认→…）；

那就需要实现一个新的协议插件（或在现有插件里增加“内嵌解析”），因为只有你明确了私有协议结构，程序才能“有语义地改”。

> 当前阶段你不确定车端情况，这类工作建议放在拿到车型/抓包/日志之后做，避免提前做错方向。

---

## 8. 依赖策略：为什么我们坚持“缺依赖就报错，不静默降级”

你明确要求：不能降级，尤其是“库没装就报错提示安装”。当前实现符合这个原则：

- Wi‑Fi：只要配置了解密，就强制要求 `pycryptodomex` 存在，否则报错 `pip install pycryptodomex`  
- CAN DBC：使用 `cantools`，没装就报错 `pip install cantools`（或安装 `requirements-dbc.txt`）

原因很简单：  
**安全测试工具最怕“看起来跑了，其实关键能力没启用”。**  
宁可早失败，也不要静默降级造成错误结论。

---

## 9. 如何验证“协议层在工作”？（最小自检方法）

你不需要懂协议细节也能做基本验证：

1) 列出插件（确认协议插件被注册）：
```bash
python fuzz/vehfuzz/scripts/vehfuzz.py plugins
```

2) 运行一个示例配置（仓库自带 examples），然后查看输出目录：
- `runs/<run_id>/artifacts/events.jsonl`

3) 观察 `events.jsonl` 中：
- 是否有 `tx_parsed/parsed`
- `parsed.protocol/level/ok/reason/encrypted/fields/payload`
- `payload_hex` 是否存在（存在说明 payload 定位成功）

单元测试也覆盖了主要解析逻辑：
```bash
python -m unittest discover -s fuzz/vehfuzz/tests -p "test_*.py"
```

---

## 10. 附录：关键代码位置索引（方便你让研发同事快速定位）

核心抽象与引擎接入：
- `fuzz/vehfuzz/src/vehfuzz/core/plugins.py`：Message/Protocol/注册与创建
- `fuzz/vehfuzz/src/vehfuzz/core/parsed.py`：ParsedMessage/ByteRange
- `fuzz/vehfuzz/src/vehfuzz/core/engine.py`：run_campaign、_safe_parse、事件落盘字段
- `fuzz/vehfuzz/src/vehfuzz/core/artifacts.py`：events.jsonl 路径与 EventLogger

协议插件：
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/can.py`
- `fuzz/vehfuzz/src/vehfuzz/core/isotp.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/uds.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/j1939.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/can_dbc.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/someip.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/someip_sd.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/doip.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/bluetooth.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/wifi.py`
- `fuzz/vehfuzz/src/vehfuzz/plugins/protocols/nmea.py`

依赖：
- `fuzz/vehfuzz/requirements.txt`：基础依赖（含 `pycryptodomex`）
- `fuzz/vehfuzz/requirements-dbc.txt`：DBC 可选依赖（`cantools`）

---

## 11. 下一步建议（不改任务书措辞的前提下，怎么把协议层“更工程化”）

你现在“不确定车企对接细节”，但你已经能确定 DBC 可能可得。建议顺序：
1) 先把 CAN 通道的 **DBC 信号级 fuzz** 跑通（最容易形成可量化效果）
2) 以 `events.jsonl` 为中心定义“协议层对 fuzz 层的契约”：每个协议必须提供哪些 fields/flow_key/payload
3) 车企对接后再补齐两类接入差异：
   - Wi‑Fi：入网明文（在线） vs 空口加密（离线/监听）
   - Bluetooth：能拿 HCI vs 只能拿应用层

> 如果你希望我继续：我可以在不做 UI 的情况下，给协议层补一份“字段字典规范”（每个协议 fields 的约定）、以及一个“解析成功率/加密占比/会话聚类”统计脚本，让任务书里的指标更可量化。
